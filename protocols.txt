               Mark 1 Serial Protocol (on /dev/ttyAMA0)

Pi -> Arduino
==========================
eyes.color=int                  int = RGB (of hex 0x00RRGGBB,
                                e.g. red = 0x00FF0000 = 16711680, so
                                "eyes.color=16711680" gives solid red eyes)
eyes.level=int                  int = brightness level, 0-
eyes.fill=int                   int = fill amount (0-23)
eyes.volume=int                 int = volume, 0-11 (it goes to 11!)
eyes.spin=int                   int = milliseconds to spin, 0 for forever
eyes.on                         int = turn on all eye pixels
eyes.off                        int = turn off all eye pixels
eyes.reset                      int = turn off all eye pixels
eyes.blink=[l/r/b]              l = left, r = right, b = both
                                (e.g. "eyes.blink=l")
eyes.narrow=[l/r/b]             make eyes "squint"
eyes.widen=[l/r/b]              make eyes go from "squint" to wide open
eyes.look=[l/r/b/u/d/c]         u = up, d = down, c = crossed
                                (e.g. "eyes.look=d")
eyes.unlook=[l/r/b/u/d/c]       reverse the "look" animation, ends at wide open
eyes.set=int,color            	int = pixel, color = RGB color

mouth.reset                     clear the matrix display
mouth.faketalk                  simple animation of mouth moving
mouth.talk                      shows mouth
mouth.listen                    begins animation of listening mouth (wavy line)
mouth.think                     begins animation of mouth going back and forth
mouth.smile                     shows smiling mouth
mouth.text=str                  scrolls text once across screen
mouth.icon=[x=#,][y=#,]image    displays an encoded image (see note 2 below)
mouth.viseme=int                displays a mouth shape viseme (see note 1 below)

system.reset                    resets the Arduino
system.mute                     mutes the audio output
system.unmute                   restores the audio output
system.blink=int                int = times to blink the Arduino's on-board LED

test.begin                      initiate a hardware test sequence
version                         reply with version, e.g. "Mycroft Mark 1 v0.1.9"

weather.display=int,image       int = temperature, image shown to the left of it


Arduino -> Pi
==========================
Generated upon boot/restart
   "Mycroft Hardware v0.1.9 - Connected"

Generated when the top encoder button is pressed
   "mycroft.stop"

Generated when the top encoder button is turned
   "volume.up"
   "volume.down"

Sequence generated by the hardware testing process
   "system.test.begin"
   "mic.test"
   "system.test.end"

Generated from the menu system
   "unit.reboot"                user selected REBOOT from menu
   "unit.setwifi"               user selected WIFI from menu
   "unit.shutdown"              user selected OFF from menu
   "unit.factory-reset"         user selected RESET from menu
   "update                      user used ILLUM on menu
    <brightness>"
   "mycroft.mark1.demo"         user selected DEMO from menu
   "unit.enable-ssh"            user selected SSH > ALLOW
   "unit.disable-ssh"           user selected SSH > BLOCK
   "unit.enable-learning"       user selected LEARN > ALLOW
   "unit.disable-learning"      user selected LEARN > OFF


NOTES
==========================

1) Visemes

Visemes are representations of the shape of a human mouth when speaking.
The Mycroft Mark 1 uses this to make his "lips" match his speech.  He
does this using six basic visemes.

   0 = wide open
   1 = pursed
   2 = open
   3 = narrow lips
   4 = closed lips
   5 = parted lips
   6 = barely open lips

See mycroft/tts/mimic_tts.py for details on the mapping of phonemmes to
these visemes.

2) Images and Animation

Two-color (black/white) images can be encoded and sent to the Mark 1
faceplate.  The images can be created using editor.html in the same
directory as this note.  Just check the "Icon Encode" checkbox and
click in the squares to draw. NOTE: Large images are a special case
and must be handled separately. See below.

A blank 16x8 image looks like this:
  QIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
And a simple 16x8 boat icon look like this:
  QIAAABACAGIEMEOEPHAEAGACABABAAAAAA

You can send this image to the faceplate using this command line:
  echo "mouth.icon=QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0

You can make it "sail" with this animation sequence:
  echo "mouth.icon=x=0,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=1,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=2,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=3,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=4,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=5,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=6,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=7,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=8,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=9,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0

Or tragically sink like this:
  echo "mouth.icon=x=9,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=8,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=7,y=1,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=6,y=2,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=5,y=3,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=5,y=4,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=4,y=5,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=4,y=6,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=3,y=7,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0
  echo "mouth.icon=x=2,y=8,QIAAABACAGIEMEOEPHAEAGACABABAAAAAA" > /dev/ttyAMA0

The sinking is actually a good example of bad animation, because the Arduino
doesn't 'clip' the image as it is writing" past the bounds of the screen.  So
you might see glitches.  The correct way of doing this is to produce images
that have the bottom rows cut off as it sinks.

LARGE IMAGES

You might notice that images much larger than the sailboat above will not
appear on the faceplate. This is due to the Arduino's serial port buffer 
limiting the number of characters that can be sent. To get around this, 
you must split a long image encoding by ending it with a '$', then send 
another protocol beginning with a '$' that finishes the encoding. Like so:

  echo "mouth.icon=x=0,aIAAAAABICIEAFAFAFOFAFAFCFDFDFPF$" > /dev/ttyAMA0
  echo "mouth.icon=$AFAFAFAFAFAFIFOFOFOFOFOFIEICABAAAA" > /dev/ttyAMA0

The mouth_display function in the enclosure API handles this automatically.

